感觉这题应该会有很多非预期解，如果有人想到的话。这里说一下出题人预想的做法吧。

## 读题

`cipher_diff`函数的输入是一个16字节的明文`msg`。`sbox`函数的作用是对`state`的16个字节进行一个置换，用到的这个置换已经公开了，就是`permutation`。然后，`cipher_diff`函数用`msg`计算出两个`state`。其中，`state1`是把`msg`与`key`逐字节异或后，再进行一次`sbox`变换；`state2`是直接对`msg`进行一次`sbox`变换。最后`cipher_diff`的输出是`state1`和`state2`逐字节异或的结果。

`main`函数则是随机生成256个明文，然后得到256个`cipher_diff`输出，写入道文件中。

注意到，两次`sbox`函数的输入的异或值是固定是，就是要求的`key`值。这是未知值。而我们已知值是256个输出的异或值。

## 做题

由于16个字节之间互不影响，下面只考虑一个字节的推导。理解之后，就明白怎么恢复出整个`key`了。

首先，题目描述中已经提示选手要关注输入的异或值和输出的异或值的关系了。我们要关注的是下面这个方程是否有解：permutation[x] xor permutation[x xor in] = out，其中的`in`和`out`是常数。

对于上述方程，我们是可以建立一个表的，设为`table[256][256]`。其中，`table[in][out]=1`表达的意思就是方程有解，如果是`0`就没有解。当你完成建立这张表后，就会发现：当输入的异或值`in`固定时，输出的异或值只会取到部分值，而不是`[0, 255]`，也就是有很多格子是`0`，只有少数是`1`。

然后，注意到前面提到的，题目中的输入的异或值就是`key`，也就是异或值是固定的。那么，对于`cipher_diff`输出的所有异或值，都必须满足上述表格`table`。

由此，我们可以枚举`key`的值，即枚举了`permutation`的输入异或值`in`，然后检查题目给出的所有`cipher_diff`，看看我们当前枚举到的输入异或值和每一个输出异或值是不是有冲突，也就是`table[in][out]`会不会为`0`。如果出现冲突，则说明当前的输入异或值不正确。

经过这样枚举筛选，会发现最后每一个`key`字节都只有一种可能情况，组合到一起就是最后的flag了。详情见wp.py代码，自己试一下就懂了。
